更新日志
2.2
新增
Animator Graph 调试和可视化工具：为 UnityHFSM 新增了一个基于代码的工具，允许您从分层状态机生成 AnimatorController。这使您可以在 Unity 编辑器中可视化地探索状态层次结构，同时也可以在运行时显示实时预览。

https://raw.githubusercontent.com/Inspiaaa/UnityHFSM/0ce3902e0f851db2926a7bdd2cfa1af65764a6e4/docs/Images/AnimatorGraphExample.png

使用示例：

csharp
void Start() {
    // 在此处设置 fsm ...

    // 创建一个可以在 Unity 编辑器中查看的 AnimatorController。
    HfsmAnimatorGraph.CreateAnimatorFromStateMachine(
        fsm,
        outputFolderPath: "Assets/DebugAnimators",
        animatorName: "StateMachine.controller");
        
    fsm.Init();
}

void Update() {
    fsm.OnLogic();

    // 通过更新附加到游戏对象的 Animator 组件来预览活动状态。
    // 点击此游戏对象并打开 Animator Controller，您可以看到状态机在运行时处于哪个状态。
    HfsmAnimatorGraph.PreviewStateMachineInAnimator(fsm, animator);
}
通过代码进行高级状态机检查：从代码检查和分析分层状态机的能力得到了极大改进。这为在状态层次结构上运行的动态工具（例如新的 Animator Graph 生成器）奠定了基础。

在状态类型上实现了访问者模式，使您可以更轻松地与不同的（泛型）类交互。请参阅 StateBase 中的新 AcceptVisitor(...) 方法和 IStateVisitor 接口。

新的 StateMachineWalker 类可用于递归遍历状态层次结构。它开箱即用地支持为每个层级使用不同的泛型类型参数。

StateMachinePath 是检查相关代码使用的新类。它是一种轻量级、可哈希和可比较的类型，可用于唯一标识层次结构中的状态，避免使用更简单的基于字符串的方法可能产生的命名冲突。它同样支持为每个级别使用不同的状态 ID 类型。

StateMachine 提供了新方法，让您可以在运行时提取添加的状态和转换。

GetStartStateName

GetAllStates 和 GetAllStateNames

GetAllTransitions, GetAllTransitionsFromAny, GetAllTriggerTransitions, GetAllTriggerTransitionsFromAny

StateMachine 类有两个新属性：PendingState 和 PendingStateName，允许您获取待定（延迟）转换的目标状态。

DecoratedTransition 中的新回调：（有关包装器类更改的更多信息，请参见下文）。包装器类允许您添加自定义回调，在转换发生时和发生后运行：

csharp
fsm.AddTransition(new DecoratedTransition(someTransition, 
    beforeOnTransition: t => Debug.Log("Called before onTransition of wrapped transition")
));
改进和变更
改进了 UnityHFSM 的性能：

转换的总体性能得到了改进。

具有可以立即退出的退出时间的状态转换现在快了约 20%。

具有每帧延迟转换的开销最多减少了 60%。

状态和转换包装器类已被重构：

类已重命名以反映底层设计模式：StateWrapper -> StateDecorator, WrappedState -> DecoratedState, TransitionWrapper -> TransitionDecorator, WrappedTransition -> DecoratedTransition

之前嵌套在装饰器中的实际“包装器”类，现在已成为自己文件中的独立类。这使得它们更容易用于“一次性”应用程序，并提高了它们在代码库中的可见性。

IStateMachine 接口已被重构并拆分为两个接口：

IStateTimingManager：这本质上是旧版本中的 IStateMachine。它的新名称更准确地强调了其目的。

IStateMachine<T>：此接口扩展了 IStateTimingManager 接口，使您无需执行强制转换即可更轻松地访问 StateMachines 中的某些信息。（例如访问当前状态、待定状态、按名称获取状态的方法）

更好的错误信息：得益于新的内省基础架构，内置错误信息得到了改进：状态机异常现在包含有关问题在层次结构中发生位置的信息。例如：

text
StateMachineException: 
在状态机 'Root/Fight' 中
上下文：正在运行 OnLogic
问题：活动状态为 null，因为状态机尚未设置。
解决方案：调用 fsm.SetStartState(...) 和 fsm.Init() 或 fsm.OnEnter() 来初始化状态机。
改进了文档：代码中的 XML 文档注释（在检查方法/类时在 IDE 中显示）在措辞、覆盖范围和格式方面得到了改进。

重构：为了使代码库更易于维护并防止因意外更改本应为常量的字段而导致的错误，许多状态和转换字段已设置为 readonly（部分也为 private）。如果您依赖它们的可变性来实现动态行为，请在您的 UnityHFSM 本地副本中简单地移除 readonly 属性。

修复
修复了 ParallelStates 内部的 StateMachine 不响应全局触发器 (#48) 的错误。

修复了 ParallelStates 中与事件相关的错误，该错误会在前一个状态导致退出/转换后错误地调用子状态的某些方法（例如 Trigger 和 OnLogic）。

2.1
新增
记住最后一个状态：这是 StateMachine 类构造函数中的一个新参数，对于嵌套状态机很有用。当设置为 true 时，它使状态机在进入时返回到其最后的活动状态，而不是其原始的起始状态。您也可以在 HybridStateMachine 类中使用此功能。

并行运行状态：新的 ParallelStates 类允许您并行运行多个状态。如果 needsExitTime 设置为 true，它将等待任何子状态调用 StateCanExit 后才退出。可以通过提供自定义的 canExit 函数来覆盖此行为。

例如：

csharp
var attackFsm = new StateMachine();
attackFsm.AddState("Idle");
attackFsm.AddState("Attack");
// ...

fsm.AddState("A", new ParallelStates(
    new State(onLogic: s => MoveTowardsPlayer()),
    new State(onLogic: s => Animate()),
    attackFsm
));
使用自定义的 canExit 函数：

csharp
fsm.AddState("A", new ParallelStates(
    canExit: s => IsPlayerInRange(),
    needsExitTime: true,

    new State(onLogic: s => MoveTowardsPlayer()),
    new State(onLogic: s => Animate())
));
活动状态改变事件：StateMachine 类现在有一个新事件，您可以订阅它，当活动状态改变时触发：

例如：

csharp
fsm.StateChanged += state => print(state.name);

fsm.AddState("A");
fsm.AddState("B");
fsm.AddTransition("A", "B");

fsm.Init();  // 打印 "A"

fsm.OnLogic();  // 打印 "B"
改进
当状态具有多个传出转换时，改进了 StateMachine 类的 OnLogic 和 Trigger 方法的性能。根据转换数量，当使用字符串状态名称时，这可以使 OnLogic 方法快达 15%。

遵循 C# 事件命名约定，改进了键/鼠标转换类的命名。

TransitionOnKey.Press 现在改为 TransitionOnKey.Pressed

TransitionOnKey.Release 现在改为 TransitionOnKey.Released

TransitionOnMouse.Press 现在改为 TransitionOnMouse.Pressed

TransitionOnMouse.Release 现在改为 TransitionOnMouse.Released

改进了文档。

修复
修复了关于 State 类的 canExit 功能的不正确执行顺序（计时）错误。

修复了在检查器中显示的 State 和 State 派生类的反序列化期间出现的访问 Time.time 的异常错误。

修复了 StateWrapper.WrappedState 类中 GetActiveHierarchyPath() 的不正确输出。

2.0.1
修复
修复示例无法编译的问题。

重新引入了在先前版本中丢失的 CoState 类中的 timer 属性。

2.0
新增
幽灵状态：幽灵状态是状态机不希望停留并会尽快尝试退出的状态。这意味着 fsm 可以在一次 OnLogic 调用中进行多次转换。所有状态类型都通过设置 isGhostState 字段支持“幽灵状态行为”。

例如：

csharp
fsm.AddState("A", onEnter: s => print("A"));
fsm.AddState("B", new State(onEnter: s => print("B"), isGhostState: true));
fsm.AddState("C", onEnter: s => print("C");

fsm.AddTransition("A", "B");
fsm.AddTransition("B", "C");

fsm.Init(); // 打印 "A"
fsm.OnLogic(); // 打印 "B" 然后 "C"
退出转换：退出转换最终提供了一种简单而强大的方式来定义嵌套状态机的退出条件，本质上提升了分层状态机背后的机制。以前，决定 needsExitTime 的嵌套状态机何时可以退出的规则是隐式的、不够灵活且不受开发人员控制的。

csharp
var nested = new StateMachine(needsExitTime: true);
nested.AddState("A");
nested.AddState("B");
// ...

// 只有当嵌套 fsm 处于 "B" 状态且变量 x 等于 0 时，它才能退出。
move.AddExitTransition("B", t => x == 0);
退出转换也可以为所有状态定义（AddExitTransitionFromAny），作为触发器转换（AddExitTriggerTransition），或同时作为两者（AddExitTriggerTransitionFromAny）。

转换回调：新功能允许您定义一个在转换成功时调用的函数。它支持所有转换类型（例如触发器转换、从任意状态的转换、退出转换等）。

csharp
fsm.AddTransition(
    new Transition("A", "B", onTransition: t => print("Transition"))
);
使用快捷方法时也支持此功能：

csharp
// 可以使用快捷方法缩短：
fsm.AddTransition("A", "B", onTransition: t => print("Transition"));
print 函数将在转换之前被调用。您也可以定义一个在转换之后调用的回调：

csharp
  fsm.AddTransition("A", "B",
    onTransition: t => print("Before"),
    afterTransition: t => print("After")
);
支持 HybridStateMachine 中的自定义动作，就像在普通的 State 类中一样：

csharp
var hybrid = new HybridStateMachine();
hybrid.AddState("A", new State().AddAction("Action", () => print("A")));
hybrid.AddAction("Action", () => print("Hybrid"));

hybrid.Init();
hybrid.OnAction("Action");  // 先打印 "Hybrid"，然后打印 "A"
HybridStateMachine 中的选项，用于在其活动子状态的 OnEnter / OnLogic / ... 之前和之后运行自定义代码。以前，您只能添加在子状态的相应方法之后运行的自定义回调。迁移到此版本时，只需将构造函数中的 onEnter 参数替换为 afterOnEnter。例如：

csharp
var hybrid = new HybridStateMachine(
    beforeOnEnter: fsm => print("Before OnEnter"),
    afterOnLogic: fsm => print("After OnLogic")
    // ...
)
用于获取状态层次结构中活动路径的功能：在调试时，不仅查看根状态机的活动状态（使用 ActiveStateName）通常很有用，还要查看任何嵌套状态机中哪个状态是活动的。现在可以使用新的 GetActiveHierarchyPath() 方法检索此状态路径：

csharp
var fsm = new StateMachine();
var move = new StateMachine();
var jump = new StateMachine();

fsm.AddState("Move", move);
move.AddState("Jump", jump);
jump.AddState("Falling");

fsm.Init();
print(fsm.GetActiveHierarchyPath());  // 打印 "/Move/Jump/Falling"
CoState 中的选项，用于仅运行协程一次。例如：

csharp
var state = new CoState(mono, myCoroutine, loop: false);
TransitionAfterDynamic 中的选项，仅在 from 状态进入时评估动态延迟。这很有用，例如当转换的延迟应该是随机的时候。例如：

csharp
fsm.AddTransition(new TransitionAfterDynamic(
    "A", "B", t => Random.Range(2, 10), onlyEvaluateDelayOnEnter: true
));
改进
State 和 CoState 中的 canExit 功能：确定状态何时准备好退出以允许另一个转换的自定义 canExit 函数现在在每次有转换待定时都会被调用，而不仅仅是在 OnExitRequest 时。这更直观，因此可以防止出现一些意外行为。

CoState 类的构造函数现在还允许您传入一个 IEnumerator 函数作为协程，该函数不将 CoState 作为参数。

直接在 IDE 中可见的类/参数/...的更多文档。

内部重构使代码更易于理解和阅读。

变更
重要： UnityHFSM 的命名空间已从 FSM 更改为 UnityHFSM。这意味着您现在必须使用 using UnityHFSM。

HybridStateMachine 类构造函数中的参数 onEnter, onLogic, ... 现在等效于新参数 afterOnEnter, afterOnLogic, ...

CoState 类构造函数中的 onLogic 参数现在称为 coroutine，是第二个参数，不再是可选的。

修复
修复了多个与延迟转换（待定转换系统）相关的错误。

1.9
新增
动作系统，允许在 OnLogic 之外添加和调用自定义函数。

例如：

csharp
var state = new State()
  .AddAction("OnGameOver", () => print("Good game"))
  .AddAction<Collision2D>("OnCollision", collision => print(collision));

fsm.AddState("State", state);
fsm.Init();

fsm.OnAction("OnGameOver");  // 打印 "Good game"
fsm.OnAction<Collision2D>("OnCollision", new Collision2D());
双向转换：新功能允许状态机在条件为真时从源状态转换到目标状态，并在条件为假时从目标状态转换回源状态：

csharp
fsm.AddTwoWayTransition("Idle", "Shoot", t => isInRange);

// 等同于
fsm.AddTransition("Idle", "Shoot", t => isInRange);
fsm.AddTransition("Shoot", "Idle", t => ! isInRange);
csharp
fsm.AddTwoWayTransition(transition);
fsm.AddTwoWayTriggerTransition(transition);
TransitionOnMouse 类，用于当特定鼠标按钮被按下/释放/...时应发生的可读转换。它类似于 TransitionOnKey。

例如：

csharp
fsm.AddTransition(new TransitionOnMouse.Down("Idle", "Shoot", 0));
改进
在许多情况下，通过防止装箱和最小化 GC 分配，改进了值类型作为状态名称（例如 State<int>）的性能。

变更
StateBase 类的 RequestExit() 方法已重命名为 OnExitRequest() 以提高清晰度。

状态机的“快捷方法”已作为扩展方法移至专用类。这不会以任何方式改变 API 或用法，但使内部代码更清晰。-> 此更改减少了基 StateMachine 类与 State / Transition 类之间的耦合。相反，StateMachine 仅依赖于 StateBase 和 TransitionBase 类。这尤其表明扩展方法是可选的，并非根本上必需。

为了允许更好的测试和更多自定义，对 Timer 类的引用已替换为 ITimer 接口。这允许您为您的用例编写自定义计时器，并使基于时间的转换更容易测试。

csharp
// 之前
if (timer > 2) { }

// 现在
if (timer.Elapsed > 2) { }
由于动作系统的实现方式，State 和 CoState 的 onEnter / onLogic / onExit 输入参数的泛型数据类型已更改。State 类现在需要两个泛型类型参数：一个用于其 ID 的类型，另一个用于动作 ID 的类型。

之前：

csharp
void FollowPlayer(State<string> state)
{
    // ...
}

fsm.AddState("FollowPlayer", onLogic: FollowPlayer);
现在：

csharp
void FollowPlayer(State<string, string> state)
{
    // ...
}

fsm.AddState("FollowPlayer", onLogic: FollowPlayer);
（内部变更）重构了 src 文件夹，使其更清晰。

修复
修复了使用 AddTransitionFromAny 快捷方法时抛出 ArgumentNullException 的问题。

1.8 - 泛型
UnityHFSM 的 1.8 版本增加了对泛型的支持。现在可以轻松更改状态标识符/名称和事件名称的数据类型。得益于新的“快捷方法”，可以用比以往更少的样板代码编写状态机，并且在某些情况下（例如空状态）可以自动为您优化。

新增
支持状态标识符和事件名称的泛型。

用于减少样板和自动优化的“快捷方法”。

csharp
fsm.AddState("FollowPlayer", new State(
    onLogic: s => MoveTowardsPlayer()
));
// 现在
fsm.AddState("FollowPlayer", onLogic: s => MoveTowardsPlayer());
csharp
fsm.AddState("ExtractIntel", new State());
// 现在
fsm.AddState("ExtractIntel");
csharp
fsm.AddTransition(new Transition("A", "B"));
// 现在
fsm.AddTransition("A", "B");
支持通过 Unity 的包管理器 UPM 安装包。

项目示例。

变更
State 的 onEnter / onLogic / onExit 输入参数的数据类型已更改。这是由于继承层次结构以及将泛型支持添加到代码库的方式，同时仍试图保留字符串版本的易用性。

之前：

csharp
void FollowPlayer(State state)
{
    // ...
}

fsm.AddState("FollowPlayer", new State(onLogic: FollowPlayer));
现在：

csharp
void FollowPlayer(State<string> state)
{
    // ...
}

fsm.AddState("FollowPlayer", new State(onLogic: FollowPlayer));
状态和转换默认不再持有 MonoBehaviour 的引用。

现在 StateMachine 的构造函数不再需要 mono => new StateMachine() 而不是 new StateMachine(this)

mono 的引用必须传入 CoState 构造函数 => new CoState(this, ...)

修复
修复了当事件被激活但没有活动的触发器转换使用此事件时抛出 KeyNotFoundException 的问题。

修复了状态更改时事件顺序不正确的问题，该问题在加载新的活动转换/触发器转换之前调用了 OnEnter 方法。